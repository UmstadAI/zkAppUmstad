{
    "Bool": "\n\u25b8 **Bool**(`...args`): [`Bool`](classes/Bool.md)\n\nA boolean value. You can create it like this:\n\n**`Example`**\n\n```\nconst b = Bool(true);\n```\n\nYou can also combine multiple Bools with boolean operations:\n\n**`Example`**\n\n```ts\nconst c = Bool(false);\n\nconst d = b.or(c).and(false).not();\n\nd.assertTrue();\n```\n\nBools are often created by methods on other types such as `Field.equals()`:\n\n```ts\nconst b: Bool = Field(5).equals(6);\n```\n\n",
    "BoolVar": "\n\u01ac **BoolVar**: [`FieldVar`](modules.md#fieldvar-1)\n\n",
    "Cache": "\n\u2022 **Cache**: `Object`\n\n",
    "CacheHeader": "\n\u01ac **CacheHeader**: `StepKeyHeader`<``\"step-pk\"``\\> \\| `StepKeyHeader`<``\"step-vk\"``\\> \\| `WrapKeyHeader`<``\"wrap-pk\"``\\> \\| `WrapKeyHeader`<``\"wrap-vk\"``\\> \\| `PlainHeader`<``\"srs\"``\\> \\| `PlainHeader`<``\"lagrange-basis\"``\\> & `CommonHeader`\n\nA header that is passed to the caching layer, to support rich caching strategies.\n\nBoth `uniqueId` and `programId` can safely be used as a file path.\n\n",
    "ConstantField": "\n\u01ac **ConstantField**: [`Field`](classes/Field.md) & { `value`: `ConstantFieldVar`  }\n\n",
    "DeployArgs": "\n\u01ac **DeployArgs**: { `verificationKey?`: { `data`: `string` ; `hash`: `string` \\| [`Field`](modules.md#field-1)  } ; `zkappKey?`: [`PrivateKey`](classes/PrivateKey.md)  } \\| `undefined`\n\n",
    "Empty": "\n\u2022 **Empty**: `ProvablePureExtended`<`undefined`, ``null``\\>\n\n",
    "FeatureFlags": "\n\u01ac **FeatureFlags**: `Object`\n\n",
    "Field": "\n\u25b8 **Field**(`...args`): [`Field`](classes/Field.md)\n\nA [Field](modules.md#field-1) is an element of a prime order [finite field](https://en.wikipedia.org/wiki/Finite_field).\nEvery other provable type is built using the [Field](modules.md#field-1) type.\n\nThe field is the [pasta base field](https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/) of order 2^254 + 0x224698fc094cf91b992d30ed00000001 ([ORDER](classes/Field.md#order)).\n\nYou can create a new Field from everything \"field-like\" (`bigint`, integer `number`, decimal `string`, `Field`).\n\n**`Example`**\n\n```\nField(10n); // Field construction from a bigint\nField(100); // Field construction from a number\nField(\"1\"); // Field construction from a decimal string\n```\n\n**Beware**: Fields _cannot_ be constructed from fractional numbers or alphanumeric strings:\n```ts\nField(3.141); // ERROR: Cannot convert a float to a field element\nField(\"abc\"); // ERROR: Invalid argument \"abc\"\n```\n\nCreating a Field from a negative number can result in unexpected behavior if you are not familiar with [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic).\n\n**`Example`**\n\n```\nconst x = Field(-1); // valid Field construction from negative number\nconst y = Field(Field.ORDER - 1n); // same as `x`\n```\n\n**Important**: All the functions defined on a Field (arithmetic, logic, etc.) take their arguments as \"field-like\".\nA Field itself is also defined as a \"field-like\" element.\n\n",
    "FieldConst": "\n\u2022 **FieldConst**: `Object`\n\n",
    "FieldVar": "\n\u2022 **FieldVar**: `Object`\n\n",
    "FlexibleProvable": "\n\u01ac **FlexibleProvable**<`T`\\>: [`Provable`](modules.md#provable-1)<`T`\\> \\| [`Struct`](modules.md#struct)<`T`\\>\n\n",
    "FlexibleProvablePure": "\n\u01ac **FlexibleProvablePure**<`T`\\>: [`ProvablePure`](interfaces/ProvablePure.md)<`T`\\> \\| `StructPure`<`T`\\>\n\n",
    "Gate": "\n\u01ac **Gate**: `Object`\n\n",
    "GateType": "\n\u01ac **GateType**: ``\"Zero\"`` \\| ``\"Generic\"`` \\| ``\"Poseidon\"`` \\| ``\"CompleteAdd\"`` \\| ``\"VarbaseMul\"`` \\| ``\"EndoMul\"`` \\| ``\"EndoMulScalar\"`` \\| ``\"Lookup\"`` \\| ``\"RangeCheck0\"`` \\| ``\"RangeCheck1\"`` \\| ``\"ForeignFieldAdd\"`` \\| ``\"ForeignFieldMul\"`` \\| ``\"Xor16\"`` \\| ``\"Rot64\"``\n\n",
    "Group": "\n\u25b8 **Group**(`...args`): [`Group`](classes/Group.md)\n\nAn element of a Group.\n\n",
    "InferProvable": "\n\u01ac **InferProvable**<`A`\\>: `A` extends `Constructor`<infer U\\> ? `A` extends [`Provable`](interfaces/Provable.md)<`U`\\> ? `U` : `A` extends `Struct`<`U`\\> ? `U` : `InferProvableBase`<`A`\\> : `InferProvableBase`<`A`\\>\n\n",
    "JsonGate": "\n\u01ac **JsonGate**: `Object`\n\n",
    "JsonProof": "\n\u01ac **JsonProof**: `Object`\n\n",
    "MlFeatureFlags": "\n\u01ac **MlFeatureFlags**: [\\_: 0, rangeCheck0: MlBool, rangeCheck1: MlBool, foreignFieldAdd: MlBool, foreignFieldMul: MlBool, xor: MlBool, rot: MlBool, lookup: MlBool, runtimeTables: MlBool]\n\n",
    "MlPublicKey": "\n\u01ac **MlPublicKey**: [\\_: 0, x: FieldConst, isOdd: MlBool]\n\n",
    "MlPublicKeyVar": "\n\u01ac **MlPublicKeyVar**: [\\_: 0, x: FieldVar, isOdd: BoolVar]\n\n",
    "Provable": "\n\u2022 **Provable**: `Object`\n\n",
    "ProvableExtended": "\n\u01ac **ProvableExtended**<`T`, `TJson`\\>: [`Provable`](modules.md#provable-1)<`T`\\> & `ProvableExtension`<`T`, `TJson`\\>\n\n",
    "Reducer": "\n\u25b8 **Reducer**<`T`, `A`\\>(`reducer`): `ReducerReturn`<`A`\\>\n\n",
    "State": "\n\u25b8 **State**<`A`\\>(): [`State`](modules.md#state)<`A`\\>\n\n",
    "Struct": "\n\u25b8 **Struct**<`A`, `T`, `J`, `Pure`\\>(`type`): (`value`: `T`) => `T` & { `_isStruct`: ``true``  } & `Pure` extends ``true`` ? [`ProvablePure`](interfaces/ProvablePure.md)<`T`\\> : [`Provable`](modules.md#provable-1)<`T`\\> & { `fromJSON`: (`x`: `J`) => `T` ; `toInput`: (`x`: `T`) => { `fields?`: [`Field`](modules.md#field-1)[] ; `packed?`: [[`Field`](modules.md#field-1), `number`][]  } ; `toJSON`: (`x`: `T`) => `J`  }\n\n`Struct` lets you declare composite types for use in o1js circuits.\n\nThese composite types can be passed in as arguments to smart contract methods, used for on-chain state variables\nor as event / action types.\n\nHere's an example of creating a \"Voter\" struct, which holds a public key and a collection of votes on 3 different proposals:\n```ts\nlet Vote = { hasVoted: Bool, inFavor: Bool };\n\nclass Voter extends Struct({\n  publicKey: PublicKey,\n  votes: [Vote, Vote, Vote]\n}) {}\n\n// use Voter as SmartContract input:\nclass VoterContract extends SmartContract {\n  \\@method register(voter: Voter) {\n    // ...\n  }\n}\n```\nIn this example, there are no instance methods on the class. This makes `Voter` type-compatible with an anonymous object of the form\n`{ publicKey: PublicKey, votes: Vote[] }`.\nThis mean you don't have to create instances by using `new Voter(...)`, you can operate with plain objects:\n```ts\nvoterContract.register({ publicKey, votes });\n```\n\nOn the other hand, you can also add your own methods:\n```ts\nclass Voter extends Struct({\n  publicKey: PublicKey,\n  votes: [Vote, Vote, Vote]\n}) {\n  vote(index: number, inFavor: Bool) {\n    let vote = this.votes[i];\n    vote.hasVoted = Bool(true);\n    vote.inFavor = inFavor;\n  }\n}\n```\n\nIn this case, you'll need the constructor to create instances of `Voter`. It always takes as input the plain object:\n```ts\nlet emptyVote = { hasVoted: Bool(false), inFavor: Bool(false) };\nlet voter = new Voter({ publicKey, votes: Array(3).fill(emptyVote) });\nvoter.vote(1, Bool(true));\n```\n\nIn addition to creating types composed of Field elements, you can also include auxiliary data which does not become part of the proof.\nThis, for example, allows you to re-use the same type outside o1js methods, where you might want to store additional metadata.\n\nTo declare non-proof values of type `string`, `number`, etc, you can use the built-in objects `String`, `Number`, etc.\nHere's how we could add the voter's name (a string) as auxiliary data:\n```ts\nclass Voter extends Struct({\n  publicKey: PublicKey,\n  votes: [Vote, Vote, Vote],\n  fullName: String\n}) {}\n```\n\nAgain, it's important to note that this doesn't enable you to prove anything about the `fullName` string.\nFrom the circuit point of view, it simply doesn't exist!\n\n",
    "TransactionStatus": "\n\u01ac **TransactionStatus**: ``\"INCLUDED\"`` \\| ``\"PENDING\"`` \\| ``\"UNKNOWN\"``\n\nINCLUDED: A transaction that is on the longest chain\n\nPENDING: A transaction either in the transition frontier or in transaction pool but is not on the longest chain\n\nUNKNOWN: The transaction has either been snarked, reached finality through consensus or has been dropped\n\n",
    "Undefined": "\n\u2022 **Undefined**: `ProvablePureExtended`<`undefined`, ``null``\\>\n\n",
    "Void": "\n\u2022 **Void**: `ProvablePureExtended`<`void`, ``null``\\>\n\n",
    "ZkappPublicInput": "\n\u2022 **ZkappPublicInput**: [`ProvablePure`](interfaces/ProvablePure.md)<{ `accountUpdate`: [`Field`](classes/Field.md) = Field; `calls`: [`Field`](classes/Field.md) = Field }\\> & `ProvableExtension`<{ `accountUpdate`: [`Field`](classes/Field.md) = Field; `calls`: [`Field`](classes/Field.md) = Field }, { `accountUpdate`: `string` = Field; `calls`: `string` = Field }\\>\n\n",
    "Gadgets": "\n\u2022 `Const` **Gadgets**: `Object`\n\n",
    "Permissions": "\n\u2022 **Permissions**: `Object`\n\n",
    "Pickles": "\n\u2022 **Pickles**: `Object`\n\n",
    "Poseidon": "\n\u2022 `Const` **Poseidon**: `Object`\n\n",
    "Snarky": "\n\u2022 **Snarky**: `Object`\n\nInternal interface to snarky-ml\n\nNote for devs: This module is intended to closely mirror snarky-ml's core, low-level APIs.\n\n",
    "Test": "\n\u2022 `Const` **Test**: `Object`\n\n",
    "TokenId": "\n\u2022 `Const` **TokenId**: `Object`\n\n",
    "isReady": "\n\u2022 **isReady**: `Promise`<`void`\\>\n\n**`Deprecated`**\n\n`await isReady` is no longer needed. Remove it from your code.\n\n",
    "Account": "\n\u25b8 **Account**(`address`, `tokenId?`): `Account`\n\n",
    "MerkleWitness": "\n\u25b8 **MerkleWitness**(`height`): typeof `BaseMerkleWitness`\n\nReturns a circuit-compatible Witness for a specific Tree height.\n\n",
    "ZkProgram": "\n\u25b8 **ZkProgram**<`StatementType`, `Types`\\>(`config`): { `analyzeMethods`: () => `ReturnType`<typeof `analyzeMethod`\\>[] ; `compile`: (`options?`: { `cache`: [`Cache`](modules.md#cache-1)  }) => `Promise`<{ `verificationKey`: `string`  }\\> ; `digest`: () => `string` ; `name`: `string` ; `publicInputType`: `ProvableOrUndefined`<`Get`<`StatementType`, ``\"publicInput\"``\\>\\> ; `publicOutputType`: `ProvableOrVoid`<`Get`<`StatementType`, ``\"publicOutput\"``\\>\\> ; `verify`: (`proof`: [`Proof`](classes/Proof.md)<`InferProvableOrUndefined`<`Get`<`StatementType`, ``\"publicInput\"``\\>\\>, `InferProvableOrVoid`<`Get`<`StatementType`, ``\"publicOutput\"``\\>\\>\\>) => `Promise`<`boolean`\\>  } & { [I in keyof Types]: Prover<InferProvableOrUndefined<Get<StatementType, \"publicInput\"\\>\\>, InferProvableOrVoid<Get<StatementType, \"publicOutput\"\\>\\>, Types[I]\\> }\n\n",
    "addCachedAccount": "\n\u25b8 **addCachedAccount**(`partialAccount`, `graphqlEndpoint?`): `void`\n\nAdds an account to the local cache, indexed by a GraphQL endpoint.\n\n",
    "arrayProp": "\n\u25b8 **arrayProp**<`T`\\>(`elementType`, `length`): (`target`: `any`, `key`: `string`) => `void`\n\n",
    "checkZkappTransaction": "\n\u25b8 **checkZkappTransaction**(`txnId`): `Promise`<{ `failureReason`: `string`[] ; `success`: `boolean` = false } \\| { `failureReason`: ``null`` = null; `success`: `boolean` = true }\\>\n\n",
    "circuitMain": "\n\u25b8 **circuitMain**(`target`, `propertyName`, `_descriptor?`): `any`\n\n",
    "declareMethods": "\n\u25b8 **declareMethods**<`T`\\>(`SmartContract`, `methodArguments`): `void`\n\n`declareMethods` can be used in place of the `@method` decorator\nto declare SmartContract methods along with their list of arguments.\nIt should be placed _after_ the class declaration.\nHere is an example of declaring a method `update`, which takes a single argument of type `Field`:\n```ts\nclass MyContract extends SmartContract {\n  // ...\n  update(x: Field) {\n    // ...\n  }\n}\ndeclareMethods(MyContract, { update: [Field] }); // `[Field]` is the list of arguments!\n```\nNote that a method of the same name must still be defined on the class, just without the decorator.\n\n",
    "declareState": "\n\u25b8 **declareState**<`T`\\>(`SmartContract`, `states`): `void`\n\n`declareState` can be used in place of the `@state` decorator to declare on-chain state on a SmartContract.\nIt should be placed _after_ the class declaration.\nHere is an example of declaring a state property `x` of type `Field`.\n```ts\nclass MyContract extends SmartContract {\n  x = State<Field>();\n  // ...\n}\ndeclareState(MyContract, { x: Field });\n```\n\nIf you're using pure JS, it's _not_ possible to use the built-in class field syntax,\ni.e. the following will _not_ work:\n\n```js\n// THIS IS WRONG IN JS!\nclass MyContract extends SmartContract {\n  x = State();\n}\ndeclareState(MyContract, { x: Field });\n```\n\nInstead, add a constructor where you assign the property:\n```js\nclass MyContract extends SmartContract {\n  constructor(x) {\n    super();\n    this.x = State();\n  }\n}\ndeclareState(MyContract, { x: Field });\n```\n\n",
    "fetchAccount": "\n\u25b8 **fetchAccount**(`accountInfo`, `graphqlEndpoint?`, `\u00abdestructured\u00bb?`): `Promise`<{ `account`: [`Account`](modules/Types.md#account-1) ; `error`: `undefined`  } \\| { `account`: `undefined` ; `error`: `FetchError`  }\\>\n\nGets account information on the specified publicKey by performing a GraphQL query\nto the specified endpoint. This will call the 'GetAccountInfo' query which fetches\nzkapp related account information.\n\nIf an error is returned by the specified endpoint, an error is thrown. Otherwise,\nthe data is returned.\n\n",
    "fetchEvents": "\n\u25b8 **fetchEvents**(`accountInfo`, `graphqlEndpoint?`, `filterOptions?`): `Promise`<{ `blockHash`: `string` = event.blockInfo.stateHash; `blockHeight`: [`UInt32`](classes/UInt32.md) ; `chainStatus`: `string` = event.blockInfo.chainStatus; `events`: { `data`: `string`[] ; `transactionInfo`: { `hash`: `string` ; `memo`: `string` ; `status`: `string`  }  }[] ; `globalSlot`: [`UInt32`](classes/UInt32.md) ; `parentBlockHash`: `string` = event.blockInfo.parentHash }[]\\>\n\nAsynchronously fetches event data for an account from the Mina Archive Node GraphQL API.\n\n**`Async`**\n\n**`Throws`**\n\nIf the GraphQL request fails or the response is invalid.\n\n**`Example`**\n\n```ts\nconst accountInfo = { publicKey: 'B62qiwmXrWn7Cok5VhhB3KvCwyZ7NHHstFGbiU5n7m8s2RqqNW1p1wF' };\nconst events = await fetchEvents(accountInfo);\nconsole.log(events);\n```\n\n",
    "fetchLastBlock": "\n\u25b8 **fetchLastBlock**(`graphqlEndpoint?`): `Promise`<`PreconditionBaseTypes`<{ `blockchainLength`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: { `lower`: [`UInt32`](classes/UInt32.md) ; `upper`: [`UInt32`](classes/UInt32.md)  }  } ; `globalSlotSinceGenesis`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: { `lower`: [`UInt32`](classes/UInt32.md) ; `upper`: [`UInt32`](classes/UInt32.md)  }  } ; `minWindowDensity`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: { `lower`: [`UInt32`](classes/UInt32.md) ; `upper`: [`UInt32`](classes/UInt32.md)  }  } ; `nextEpochData`: { `epochLength`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: { `lower`: [`UInt32`](classes/UInt32.md) ; `upper`: [`UInt32`](classes/UInt32.md)  }  } ; `ledger`: { `hash`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: [`Field`](classes/Field.md)  } ; `totalCurrency`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: { `lower`: [`UInt64`](classes/UInt64.md) ; `upper`: [`UInt64`](classes/UInt64.md)  }  }  } ; `lockCheckpoint`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: [`Field`](classes/Field.md)  } ; `seed`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: [`Field`](classes/Field.md)  } ; `startCheckpoint`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: [`Field`](classes/Field.md)  }  } ; `snarkedLedgerHash`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: [`Field`](classes/Field.md)  } ; `stakingEpochData`: { `epochLength`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: { `lower`: [`UInt32`](classes/UInt32.md) ; `upper`: [`UInt32`](classes/UInt32.md)  }  } ; `ledger`: { `hash`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: [`Field`](classes/Field.md)  } ; `totalCurrency`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: { `lower`: [`UInt64`](classes/UInt64.md) ; `upper`: [`UInt64`](classes/UInt64.md)  }  }  } ; `lockCheckpoint`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: [`Field`](classes/Field.md)  } ; `seed`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: [`Field`](classes/Field.md)  } ; `startCheckpoint`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: [`Field`](classes/Field.md)  }  } ; `totalCurrency`: { `isSome`: [`Bool`](classes/Bool.md) ; `value`: { `lower`: [`UInt64`](classes/UInt64.md) ; `upper`: [`UInt64`](classes/UInt64.md)  }  }  }\\>\\>\n\nFetches the last block on the Mina network.\n\n",
    "fetchTransactionStatus": "\n\u25b8 **fetchTransactionStatus**(`txId`, `graphqlEndpoint?`): `Promise`<[`TransactionStatus`](modules.md#transactionstatus)\\>\n\nFetches the status of a transaction.\n\n",
    "getWasm": "\n\u25b8 **getWasm**(): `WasmModule`\n\n",
    "isBool": "\n\u25b8 **isBool**(`x`): `boolean`\n\n",
    "isField": "\n\u25b8 **isField**(`x`): x is Field\n\n",
    "matrixProp": "\n\u25b8 **matrixProp**<`T`\\>(`elementType`, `nRows`, `nColumns`): (`target`: `any`, `key`: `string`) => `void`\n\n",
    "method": "\n\u25b8 **method**<`T`\\>(`target`, `methodName`, `descriptor`): `void`\n\nA decorator to use in a zkApp to mark a method as callable by anyone.\nYou can use inside your zkApp class as:\n\n```\n\\@method myMethod(someArg: Field) {\n  // your code here\n}\n```\n\n",
    "prop": "\n\u25b8 **prop**(`this`, `target`, `key`): `void`\n\n",
    "provable": "\n\u25b8 **provable**<`A`\\>(`typeObj`, `options?`): `ProvableExtended`<[`InferProvable`](modules.md#inferprovable)<`A`\\>, `InferJson`<`A`\\>\\>\n\n",
    "provablePure": "\n\u25b8 **provablePure**<`A`\\>(`typeObj`): [`ProvablePure`](interfaces/ProvablePure.md)<[`InferProvable`](modules.md#inferprovable)<`A`\\>\\> & `ProvableExtension`<[`InferProvable`](modules.md#inferprovable)<`A`\\>, `InferJson`<`A`\\>\\>\n\n",
    "public\\_": "\n\u25b8 **public_**(`target`, `_key`, `index`): `void`\n\n",
    "readVarMessage": "\n\u25b8 **readVarMessage**(`methodName`, `varName`, `varDescription`): `string`\n\n",
    "scaleShifted": "\n\u25b8 **scaleShifted**(`point`, `shiftedScalar`): [`Group`](classes/Group.md)\n\n",
    "sendZkapp": "\n\u25b8 **sendZkapp**(`json`, `graphqlEndpoint?`, `\u00abdestructured\u00bb?`): `Promise`<[`FetchResponse`, `undefined`] \\| [`undefined`, `FetchError`]\\>\n\nSends a zkApp command (transaction) to the specified GraphQL endpoint.\n\n",
    "setArchiveGraphqlEndpoint": "\n\u25b8 **setArchiveGraphqlEndpoint**(`graphqlEndpoint`): `void`\n\nSets up a GraphQL endpoint to be used for fetching information from an Archive Node.\n\n",
    "setGraphqlEndpoint": "\n\u25b8 **setGraphqlEndpoint**(`graphqlEndpoint`): `void`\n\n",
    "setGraphqlEndpoints": "\n\u25b8 **setGraphqlEndpoints**(`\u00abdestructured\u00bb`): `void`\n\n",
    "shutdown": "\n\u25b8 **shutdown**(): `void`\n\n**`Deprecated`**\n\n`shutdown()` is no longer needed, and is a no-op. Remove it from your code.\n\n",
    "state": "\n\u25b8 **state**<`A`\\>(`stateType`): (`target`: [`SmartContract`](classes/SmartContract.md) & { `constructor`: `any`  }, `key`: `string`, `_descriptor?`: `PropertyDescriptor`) => `void`\n\nA decorator to use within a zkapp to indicate what will be stored on-chain.\nFor example, if you want to store a field element `some_state` in a zkapp,\nyou can use the following in the declaration of your zkapp:\n\n```\n@state(Field) some_state = State<Field>();\n```\n\n",
    "toConstantField": "\n\u25b8 **toConstantField**(`x`, `methodName`, `varName?`, `varDescription?`): [`ConstantField`](modules.md#constantfield)\n\n",
    "toFp": "\n\u25b8 **toFp**(`x`): `Fp`\n\n",
    "verify": "\n\u25b8 **verify**(`proof`, `verificationKey`): `Promise`<`boolean`\\>\n\n",
    "withMessage": "\n\u25b8 **withMessage**(`error`, `message?`): `unknown`\n\n"
}