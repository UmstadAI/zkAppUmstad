{
	"question": "Create tic tac toe smart contract",
	"code": "/**\n * This file defines the `TicTacToe` smart contract and the helpers it needs.\n */\n\nimport {\n Field,\n State,\n PublicKey,\n SmartContract,\n state,\n method,\n Bool,\n Provable,\n Signature,\n Struct,\n} from 'o1js';\n\nexport { Board, TicTacToe };\n\nfunction Optional<T>(type: Provable<T>) {\n return class Optional_ extends Struct({ isSome: Bool, value: type }) {\n constructor(isSome: boolean | Bool, value: T) {\n super({ isSome: Bool(isSome), value });\n }\n\n toFields() {\n return Optional_.toFields(this);\n }\n };\n}\n\nclass OptionalBool extends Optional(Bool) {}\n\nclass Board {\n board: OptionalBool[][];\n\n constructor(serializedBoard: Field) {\n const bits = serializedBoard.toBits(18);\n let board = [];\n for (let i = 0; i < 3; i++) {\n let row = [];\n for (let j = 0; j < 3; j++) {\n const isPlayed = bits[i * 3 + j];\n const player = bits[i * 3 + j + 9];\n row.push(new OptionalBool(isPlayed, player));\n }\n board.push(row);\n }\n this.board = board;\n }\n\n serialize(): Field {\n let isPlayed = [];\n let player = [];\n for (let i = 0; i < 3; i++) {\n for (let j = 0; j < 3; j++) {\n isPlayed.push(this.board[i][j].isSome);\n player.push(this.board[i][j].value);\n }\n }\n return Field.fromBits(isPlayed.concat(player));\n }\n\n update(x: Field, y: Field, playerToken: Bool) {\n for (let i = 0; i < 3; i++) {\n for (let j = 0; j < 3; j++) {\n // is this the cell the player wants to play?\n const toUpdate = x.equals(new Field(i)).and(y.equals(new Field(j)));\n\n // make sure we can play there\n toUpdate.and(this.board[i][j].isSome).assertEquals(false);\n\n // copy the board (or update if this is the cell the player wants to play)\n this.board[i][j] = Provable.if(\n toUpdate,\n new OptionalBool(true, playerToken),\n this.board[i][j]\n );\n }\n }\n }\n\n printState() {\n for (let i = 0; i < 3; i++) {\n let row = '| ';\n for (let j = 0; j < 3; j++) {\n let token = '_';\n if (this.board[i][j].isSome.toBoolean()) {\n token = this.board[i][j].value.toBoolean() ? 'X' : 'O';\n }\n\n row += token + ' | ';\n }\n console.log(row);\n }\n console.log('---\\n');\n }\n\n checkWinner(): Bool {\n let won = new Bool(false);\n\n // check rows\n for (let i = 0; i < 3; i++) {\n let row = this.board[i][0].isSome;\n row = row.and(this.board[i][1].isSome);\n row = row.and(this.board[i][2].isSome);\n row = row.and(this.board[i][0].value.equals(this.board[i][1].value));\n row = row.and(this.board[i][1].value.equals(this.board[i][2].value));\n won = won.or(row);\n }\n\n // check cols\n for (let i = 0; i < 3; i++) {\n let col = this.board[0][i].isSome;\n col = col.and(this.board[1][i].isSome);\n col = col.and(this.board[2][i].isSome);\n col = col.and(this.board[0][i].value.equals(this.board[1][i].value));\n col = col.and(this.board[1][i].value.equals(this.board[2][i].value));\n won = won.or(col);\n }\n\n // check diagonals\n let diag1 = this.board[0][0].isSome;\n diag1 = diag1.and(this.board[1][1].isSome);\n diag1 = diag1.and(this.board[2][2].isSome);\n diag1 = diag1.and(this.board[0][0].value.equals(this.board[1][1].value));\n diag1 = diag1.and(this.board[1][1].value.equals(this.board[2][2].value));\n won = won.or(diag1);\n\n let diag2 = this.board[0][2].isSome;\n diag2 = diag2.and(this.board[1][1].isSome);\n diag2 = diag2.and(this.board[0][2].isSome);\n diag2 = diag2.and(this.board[0][2].value.equals(this.board[1][1].value));\n diag2 = diag2.and(this.board[1][1].value.equals(this.board[2][0].value));\n won = won.or(diag2);\n\n //\n return won;\n }\n}\n\nclass TicTacToe extends SmartContract {\n // The board is serialized as a single field element\n @state(Field) board = State<Field>();\n // false -> player 1 | true -> player 2\n @state(Bool) nextIsPlayer2 = State<Bool>();\n // defaults to false, set to true when a player wins\n @state(Bool) gameDone = State<Bool>();\n // the two players who are allowed to play\n @state(PublicKey) player1 = State<PublicKey>();\n @state(PublicKey) player2 = State<PublicKey>();\n\n init() {\n super.init();\n this.gameDone.set(Bool(true));\n this.player1.set(PublicKey.empty());\n this.player2.set(PublicKey.empty());\n }\n\n @method startGame(player1: PublicKey, player2: PublicKey) {\n // you can only start a new game if the current game is done\n this.gameDone.requireEquals(Bool(true));\n this.gameDone.set(Bool(false));\n // set players\n this.player1.set(player1);\n this.player2.set(player2);\n // reset board\n this.board.set(Field(0));\n // player 1 starts\n this.nextIsPlayer2.set(Bool(false));\n }\n\n // board:\n // x 0 1 2\n // y +----------\n // 0 | x x x\n // 1 | x x x\n // 2 | x x x\n @method play(pubkey: PublicKey, signature: Signature, x: Field, y: Field) {\n // 1. if the game is already finished, abort.\n this.gameDone.requireEquals(Bool(false)); // precondition on this.gameDone\n\n // 2. ensure that we know the private key associated to the public key\n // and that our public key is known to the zkApp\n\n // ensure player owns the associated private key\n signature.verify(pubkey, [x, y]).assertTrue();\n\n // ensure player is valid\n const player1 = this.player1.getAndRequireEquals();\n const player2 = this.player2.getAndRequireEquals();\n Bool.or(pubkey.equals(player1), pubkey.equals(player2)).assertTrue();\n\n // 3. Make sure that its our turn,\n // and set the state for the next player\n\n // get player token\n const player = pubkey.equals(player2); // player 1 is false, player 2 is true\n\n // ensure its their turn\n const nextPlayer = this.nextIsPlayer2.getAndRequireEquals();\n nextPlayer.assertEquals(player);\n\n // set the next player\n this.nextIsPlayer2.set(player.not());\n\n // 4. get and deserialize the board\n this.board.requireEquals(this.board.get()); // precondition that links this.board.get() to the actual on-chain state\n let board = new Board(this.board.get());\n\n // 5. update the board (and the state) with our move\n x.equals(Field(0))\n .or(x.equals(Field(1)))\n .or(x.equals(Field(2)))\n .assertTrue();\n y.equals(Field(0))\n .or(y.equals(Field(1)))\n .or(y.equals(Field(2)))\n .assertTrue();\n\n board.update(x, y, player);\n this.board.set(board.serialize());\n\n // 6. did I just win? If so, update the state as well\n const won = board.checkWinner();\n this.gameDone.set(won);\n }\n}",
	"test": "import { TicTacToe } from './tictactoe';\nimport {\n Field,\n Bool,\n PrivateKey,\n PublicKey,\n Mina,\n AccountUpdate,\n Signature,\n} from 'o1js';\n\ndescribe('tictactoe', () => {\n let player1: PublicKey,\n player1Key: PrivateKey,\n player2: PublicKey,\n zkAppAddress: PublicKey,\n zkAppPrivateKey: PrivateKey;\n\n beforeEach(async () => {\n let Local = Mina.LocalBlockchain({ proofsEnabled: false });\n Mina.setActiveInstance(Local);\n [{ publicKey: player1, privateKey: player1Key }, { publicKey: player2 }] =\n Local.testAccounts;\n zkAppPrivateKey = PrivateKey.random();\n zkAppAddress = zkAppPrivateKey.toPublicKey();\n });\n\n it('generates and deploys tictactoe', async () => {\n const zkApp = new TicTacToe(zkAppAddress);\n const txn = await Mina.transaction(player1, () => {\n AccountUpdate.fundNewAccount(player1);\n zkApp.deploy();\n zkApp.startGame(player1, player2);\n });\n await txn.prove();\n await txn.sign([zkAppPrivateKey, player1Key]).send();\n const board = zkApp.board.get();\n expect(board).toEqual(Field(0));\n });\n\n it('deploys tictactoe & accepts a correct move', async () => {\n const zkApp = new TicTacToe(zkAppAddress);\n\n // deploy\n let txn = await Mina.transaction(player1, () => {\n AccountUpdate.fundNewAccount(player1);\n zkApp.deploy();\n zkApp.startGame(player1, player2);\n });\n await txn.prove();\n await txn.sign([zkAppPrivateKey, player1Key]).send();\n\n // move\n const [x, y] = [Field(0), Field(0)];\n const signature = Signature.create(player1Key, [x, y]);\n txn = await Mina.transaction(player1, async () => {\n zkApp.play(player1, signature, x, y);\n });\n await txn.prove();\n await txn.sign([player1Key]).send();\n\n // check next player\n let isNextPlayer2 = zkApp.nextIsPlayer2.get();\n expect(isNextPlayer2).toEqual(Bool(true));\n });\n});"
}
