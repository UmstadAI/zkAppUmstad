{
	"question": "Create sudoku smart contract",
	"code": "import {\n Field,\n SmartContract,\n method,\n Bool,\n state,\n State,\n Poseidon,\n Struct,\n Provable,\n} from 'o1js';\n\nexport { Sudoku, SudokuZkApp };\n\nclass Sudoku extends Struct({\n value: Provable.Array(Provable.Array(Field, 9), 9),\n}) {\n static from(value: number[][]) {\n return new Sudoku({ value: value.map((row) => row.map(Field)) });\n }\n\n hash() {\n return Poseidon.hash(this.value.flat());\n }\n}\n\nclass SudokuZkApp extends SmartContract {\n @state(Field) sudokuHash = State<Field>();\n @state(Bool) isSolved = State<Bool>();\n\n /**\n * by making this a `@method`, we ensure that a proof is created for the state initialization.\n * alternatively (and, more efficiently), we could have used `super.init()` inside `update()` below,\n * to ensure the entire state is overwritten.\n * however, it's good to have an example which tests the CLI's ability to handle init() decorated with `@method`.\n */\n @method init() {\n super.init();\n }\n\n @method update(sudokuInstance: Sudoku) {\n this.sudokuHash.set(sudokuInstance.hash());\n this.isSolved.set(Bool(false));\n }\n\n @method submitSolution(sudokuInstance: Sudoku, solutionInstance: Sudoku) {\n let sudoku = sudokuInstance.value;\n let solution = solutionInstance.value;\n\n // first, we check that the passed solution is a valid sudoku\n\n // define helpers\n let range9 = Array.from({ length: 9 }, (_, i) => i);\n let oneTo9 = range9.map((i) => Field(i + 1));\n\n function assertHas1To9(array: Field[]) {\n oneTo9\n .map((k) => range9.map((i) => array[i].equals(k)).reduce(Bool.or))\n .reduce(Bool.and)\n .assertTrue('array contains the numbers 1...9');\n }\n\n // check all rows\n for (let i = 0; i < 9; i++) {\n let row = solution[i];\n assertHas1To9(row);\n }\n // check all columns\n for (let j = 0; j < 9; j++) {\n let column = solution.map((row) => row[j]);\n assertHas1To9(column);\n }\n // check 3x3 squares\n for (let k = 0; k < 9; k++) {\n let [i0, j0] = divmod(k, 3);\n let square = range9.map((m) => {\n let [i1, j1] = divmod(m, 3);\n return solution[3 * i0 + i1][3 * j0 + j1];\n });\n assertHas1To9(square);\n }\n\n // next, we check that the solution extends the initial sudoku\n for (let i = 0; i < 9; i++) {\n for (let j = 0; j < 9; j++) {\n let cell = sudoku[i][j];\n let solutionCell = solution[i][j];\n // either the sudoku has nothing in it (indicated by a cell value of 0),\n // or it is equal to the solution\n Bool.or(cell.equals(0), cell.equals(solutionCell)).assertTrue(\n `solution cell (${i + 1},${j + 1}) matches the original sudoku`\n );\n }\n }\n\n // finally, we check that the sudoku is the one that was originally deployed\n let sudokuHash = this.sudokuHash.getAndRequireEquals();\n\n sudokuInstance\n .hash()\n .assertEquals(sudokuHash, 'sudoku matches the one committed on-chain');\n\n // all checks passed => the sudoku is solved!\n this.isSolved.set(Bool(true));\n }\n}\n\nfunction divmod(k: number, n: number) {\n let q = Math.floor(k / n);\n return [q, k - q * n];\n}",
	"test": "import { Sudoku, SudokuZkApp } from './sudoku';\nimport { cloneSudoku, generateSudoku, solveSudoku } from './sudoku-lib';\nimport { PrivateKey, PublicKey, Mina, AccountUpdate } from 'o1js';\n\ndescribe('sudoku', () => {\n let zkApp: SudokuZkApp,\n zkAppPrivateKey: PrivateKey,\n zkAppAddress: PublicKey,\n sudoku: number[][],\n sender: PublicKey,\n senderKey: PrivateKey;\n\n beforeEach(async () => {\n let Local = Mina.LocalBlockchain({ proofsEnabled: false });\n Mina.setActiveInstance(Local);\n sender = Local.testAccounts[0].publicKey;\n senderKey = Local.testAccounts[0].privateKey;\n zkAppPrivateKey = PrivateKey.random();\n zkAppAddress = zkAppPrivateKey.toPublicKey();\n zkApp = new SudokuZkApp(zkAppAddress);\n sudoku = generateSudoku(0.5);\n });\n\n it('accepts a correct solution', async () => {\n await deploy(zkApp, zkAppPrivateKey, sudoku, sender, senderKey);\n\n let isSolved = zkApp.isSolved.get().toBoolean();\n expect(isSolved).toBe(false);\n\n let solution = solveSudoku(sudoku);\n if (solution === undefined) throw Error('cannot happen');\n let tx = await Mina.transaction(sender, () => {\n let zkApp = new SudokuZkApp(zkAppAddress);\n zkApp.submitSolution(Sudoku.from(sudoku), Sudoku.from(solution!));\n });\n await tx.prove();\n await tx.sign([senderKey]).send();\n\n isSolved = zkApp.isSolved.get().toBoolean();\n expect(isSolved).toBe(true);\n });\n\n it('rejects an incorrect solution', async () => {\n await deploy(zkApp, zkAppPrivateKey, sudoku, sender, senderKey);\n\n let solution = solveSudoku(sudoku);\n if (solution === undefined) throw Error('cannot happen');\n\n let noSolution = cloneSudoku(solution);\n noSolution[0][0] = (noSolution[0][0] % 9) + 1;\n\n await expect(async () => {\n let tx = await Mina.transaction(sender, () => {\n let zkApp = new SudokuZkApp(zkAppAddress);\n zkApp.submitSolution(Sudoku.from(sudoku), Sudoku.from(noSolution));\n });\n await tx.prove();\n await tx.sign([senderKey]).send();\n }).rejects.toThrow(/array contains the numbers 1...9/);\n\n let isSolved = zkApp.isSolved.get().toBoolean();\n expect(isSolved).toBe(false);\n });\n});\n\nasync function deploy(\n zkApp: SudokuZkApp,\n zkAppPrivateKey: PrivateKey,\n sudoku: number[][],\n sender: PublicKey,\n senderKey: PrivateKey\n) {\n let tx = await Mina.transaction(sender, () => {\n AccountUpdate.fundNewAccount(sender);\n zkApp.deploy();\n zkApp.update(Sudoku.from(sudoku));\n });\n await tx.prove();\n // this tx needs .sign(), because `deploy()` adds an account update that requires signature authorization\n await tx.sign([zkAppPrivateKey, senderKey]).send();\n}"
}
